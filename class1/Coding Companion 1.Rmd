---
title: "Coding Companion 1"
author: "Brian Cozzi"
date: "9/15/2020"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Understanding Basic Data Structures
The examples below show standard examples of creating and converting data types. 

### Defining some variables
The code below provides illustrative examples for creating common data types and storing them as atomic vectors

```{r Creating Data}
# Define characters
character = "3"; character = '3'; character = paste(3)
# Create a vector of characters
character_vector = c("a", "b", "c")

# Define a "double"
real_number = 4.421

# Define an integer
integer = as.integer(3); integer = 3L

# Create a matrix of doubles using an atomic vector
real_matrix = matrix(c(3.235, 323.6, .4, 967L),
                     nrow = 2)
```


### Checking and Converting Data Types
```{r Checking and Converting Data Type}
# Checking the data type
typeof(real_number); str(real_number); is.double(real_number)

# Coercion - recall that we defined the matrix above using 3 doubles and 1 Integer (967L).
is.double(real_matrix[2,2])

# Explicit Type Conversion
x = as.numeric(967L); as.double(967L)
```


## Numeric and Logical Operations
The code below shows some tricks for applying some  working with vectors. 

### Logical Operations on Character Vectors
```{r}
character_vector = c("a", "b", "c")

# Append elements to character vector
character_vector = c(character_vector, c("z", "q"), "p")

# Check if item is contained in character_vector
"a" %in% character_vector
max(character_vector == "a")
```

```{r}
# Check if multiple elements are in a character vector
c("a", "d", "f", "g", "b") %in% character_vector
```

### Logical Operations for Numeric Vectors
```{r}
# Get 10000 samples from random normal distribution with mean 3, and sd = 5
rnorm_samps = rnorm(n = 100000, mean = 3, sd = 5)
## Print this: print(rnorm_samps)

# What is the mean of this?
mean(rnorm_samps)
```

Suppose we have the following question: What % of samples are between -2 (mean - 1sd) and 8 (mean + 1sd)?

Method 1:
```{r}
# Create two logical vectors
ge_neg_2 = rnorm_samps >= -2
le_8 = rnorm_samps <= 8

# Elementwise comparison between the two logical vectors
betw_neg_2_and_8 = ge_neg_2 & le_8
mean(betw_neg_2_and_8)

```

Method 2:
```{r}
# Alternative (shorter) method
mean((rnorm_samps >= -2) & (rnorm_samps <= 8))
```

### Subsetting Matrices
Recall that we can subset matrices using logical vectors as well as numeric vectors (which correspond with the row/column number). The code below shows examples of both.
```{r}
# Create a matrix
data_matrix = matrix(c(seq(0,100), # 1, 2, ..., 100
                       seq(10,110), # 10, 11, ..., 110
                       seq(50, 150)), # 50, 51,..., 150
                     nrow = 3, 
                     byrow = TRUE)
# Create a vector for the row names
row_names = c("Row 1", "Row 2", "Row 3")

# Subset the Matrix using numeric vectors
# e.g. Select Rows 1 and 3, and columns 90 - 100
data_matrix[c(1, 3), 90:100] 
# e.g. Select the last 20 columns of the matrix
data_matrix[,(ncol(data_matrix)-19): ncol(data_matrix)]

# *Subset the Matrix using logical vector*
# e.g. Entering the logical vector manually
data_matrix[c(TRUE, FALSE, TRUE), 90:100]

# e.g. Creating Logical Vector using another vector
# The logical vector is created using %in% (see above)
row_filt = row_names %in% c("Row 1", "Row 3")
data_matrix[row_filt, 90:100]
# data_matrix[row_names %in% c("Row 1", "Row 3"), 90:100]

# e.g. Creating Logical Vector using another vector
# The logical vector is created using %in% (see above)
row_filt = data_matrix[,1] != 10
data_matrix[row_filt, 90:100]
```

We can also use these subsetting techniques to reorder the matrix. Using the *order* function returns a vector where the values correspond to the indices of the original vector once sorted.
```{r}
# Create a vector that gives the order of the elements in column 1 of data_matrix
data_matrix[,1]
order(data_matrix[,1], decreasing = TRUE) # This returns a vector
```

Ordering column 1 in reverse order (using decreasing = TRUE), tells us that the 3rd element of that column is the largest, followed by the 2nd, then 1st. 

We can then use this vector to reorder the rows of our original matrix based on the values of column 1.
```{r}
order_vector = order(data_matrix[,1], decreasing = TRUE)
ordered_matrix = data_matrix[order_vector,]
ordered_matrix[,1:5]
```


## Summary functions
```{r}
# Mean
mean(data_matrix) # Average over all elements
rowMeans(data_matrix) # Average over each row
colMeans(data_matrix) # Average over each column

# Standard Deviation/Varaince
sd(data_matrix[1,])
var(data_matrix[1,])

# Max, Min
max(data_matrix[1,])
min(data_matrix[1,])

# Summary
summary(data_matrix[,1:4]) # Summarize column 1 through 4
summary(t(data_matrix)) # Summarize each row (by transposing the matrix)

# five number summary
fivenum(data_matrix[1,])

# Quantile
quantile(data_matrix[1,]) # Another 5-number summary
quantile(data_matrix[1,], c(0, .33, .67, 1)) # Breaking the vector into thirds

```


## Loops and Control Flow
For loops allow us to iterate over a set number of elements. 

### Iterating over a character vector
In this case, we show an example where we want to print any element of character_vector_1 that is contained in character_vector_2

```{r}
character_vector_1 = c("a", "b", "c")
character_vector_2 = c("b", "c", "d", "e", "f",
                       "g", "h", "i", "j", "k")

# Loop over each element (char) of character_vector_1
for (char in character_vector_1){
  # Check if that element is in character_vector_2
  if(char %in% character_vector_2){
    # print that element
    print(char)
  }
}
```

Recall from "Logical Operators on Character Vectors" that we can do this more efficiently using *%in%*.

### Comparing elements over a sequence
Suppose we have a vector of yearly returns for an investment. If we want to calculate the change in returns from year-to-year, we may consider doing something like the following: 

```{r}
# Artificially construct yearly returns over 100 years
mean_vector = seq(0, 100, by = 1)
returns = rnorm(mean_vector, mean = mean_vector, sd = 40)

# Create an empty vector called "diff"
diff = c()
# Populate the elements of diff by calculating the difference between the current return[i] and the previous return [i]
for (i in 2:length(returns)){
  diff = c(diff, returns[i] - returns[i-1])
}

```

Can you think of a quicker way to do this using vector subsetting?

